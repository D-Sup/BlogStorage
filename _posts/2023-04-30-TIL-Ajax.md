---
title: '비동기 통신(Ajax)방식'
excerpt_separator: '<!--more-->'
categories:
  - CodeLion
tags:
  - JavaScript
header:
  teaser: ./assets/image/26.png
toc: true
toc_sticky: true
toc_label: 'CONTENTS'
---

<br>
<!-- https://kr.freepik.com/
https://ye-yo.github.io/thumbnail-maker/ -->
<!--  source ~/.bash_profile   -->
<!-- bundle exec jekyll serve -->

# 📚 What is TIL?

## AJAX가 없던 시절

> 과거에는 사용자와 상호작용하는 웹 페이지를 만들기 위해서는  
> **HTML과 함께** 폼을 이용해 데이터를 서버에 전송하고,  
> 서버에서 처리된 결과를 **다시 HTML로 받아와 화면에 출력**하는 방식을 사용했다

🔎 따라서, 페이지 내용이 변경될 때 클라이언트에서 서버에 새로운 정보를 요청하고  
&emsp;응답할 때마다 HTTP 프로토콜이 재설정되면서 페이지 **전체가 갱신**(새로고침)되었다  
🔎 하지만 이 방식은 페이지가 다시 로드되어야 하기 때문에 **사용자 경험과 성능면에서 한계**가 있었다 
{:.notice--info}

<br>

```html
<form action = "www.naver.com" type="get">
<button type="submit">
```

🔎 과거 클라이언트가 데이터를 서버에 요청하는 방법은  
&emsp;브라우저 주소창에 특정 URL을 입력하거나,  
&emsp;HTML 요소인 `<a>` 혹은 `<form>` 을 이용하는것이었다
{:.notice--info}

<br>
<br>

## AJAX
_Asynchronous JavaScript And XML_

> 서버와의 비동기 통신을 가능하게 하는 여러 기능들을 가진  
> **XMLHttpRequest** 객체를 활용한 AJAX 개념이 주목받으면서  
> 더이상 페이지의 전체 갱신이 아닌 변경되는 부분의 데이터만  
> AJAX를 통해서 받아 갱신하면서 그 문제점을 해결할 수 있게 되었다  
>
> AJAX는 자바스크립트를 이용하여 웹 페이지 내에서 **동적으로 데이터를 요청하고 받아오는 방식**으로  
> 웹 페이지에서 자바스크립트를 이용해 서버로 요청을 보내고,  
> 서버는 요청에 대한 데이터를 **JSON이나 XML 등의 형식으로 응답**한다 

💡 이렇게 자바스크립트는 비동기적으로 서버에 요청을 보낸 뒤 계속해서 다른 작업을 가능할 수 있게 되었다
{:.notice--primary}

<br>

## XMLHttpRequest

```
function xhrRequest() {

// 1. XMLHttpRequest 객체 생성
const requestObj = new XMLHttpRequest();

// 3. 서버로 보낼 Ajax 요청의 형식을 설정
requestObj.open('GET', 'url'); // 요청을 초기화합니다. 통신방법과 요청을 발신할 대상의 주소를 전달합니다.

// 2. onreadystatechange 등록
requestObj.onreadystatechange = () => { 
  // readystate 속성 값이 변경될 때마다 호출되는 이벤트리스너 입니다.
  // 서버로 부터 응답이 오게 되어 XMLHttpRequest 객체의 값이 변하게 되면 이를 감지해 자동으로 호출되는 함수를 설정한다
  // readystate : 요청을 보내는 클라이언트의 상태를 의미합니다.
  // readystate의 종류
  // 0 (UNSENT) - XHR 객체가 생성되었지만 아직 초기화되지 않았습니다.
  // 1 (OPENED) - open()함수가 호출되어 요청이 초기화되었습니다.
  // 2 (HEADERS_RECEIVED) - send()함수가 호출되었습니다.
  // 3 (LOADING) - 데이터를 다운받는 중 입니다.
  // 4 (DONE) - 통신이 완료되었습니다.

  // XMLXttpRequest 객체의 현재 상태와 서버 상의 문서 존재 유무를 확인
  if (requestObj.readyState == 4 && requestObj.status == "200") {
  // status 속성은 요청에 대한 HTTP 응답 코드를 나타냅니다.

    // 서버에 요청하여 응답으로 받은 데이터를 문자열로 반환
    const result = requestObj.responseText;
    // responseText 프로퍼티 : 서버에 요청하여 응답으로 받은 데이터를 문자열로 반환
    // responseXML 프로퍼티 : 서버에 요청하여 응답으로 받은 데이터를 XML DOM 객체로 반환
  }
};

// 4. 작성된 Ajax 요청을 서버로 전달
requestObj.send(); // 서버로 요청을 보냅니다. send 메소드가 실행되어야만 우리가 위에서 설정한 내용들이 의미를 가지게 됩니다.
// send() - GET 방식
// send(문자열) - POST 방식

}

xhrRequest();
```
{: .language-js .line-numbers}

⚠️ 비동기 처리의 문제점  
<br>
&emsp;자바스크립트는 AJAX를 통해 API 서버를 호출할 때,  
&emsp;서버로 요청을 보낸 후 응답을 기다리지 않고 다음 코드를 진행하기 때문에,  
&emsp;응답이 아직 도착하지 않았는데도 다음 코드가 실행될 수 있다  
{:.notice--warning}

 
🔎 이러한 문제를 해결하기 위해 비동기적 처리의 실행 순서를  
&emsp;제어하기 위한 방법으로 **콜백함수**를 사용했다  
&emsp;따라서, AJAX 요청에 대한 응답이 도착했을 때  
&emsp;콜백함수가 실행되어 처리할 수 있도록 하여 원하는 기능을 수행할 수 있다  
<br>
🔎 데이터를 받아와서 데이터를 재가공하는 과정에서  
&emsp;여러가지 함수를 호출시켜야 하는 상황이 벌어질 수 있는데,  
&emsp;콜백 함수를 중첩해서 사용하다보면 **콜백 지옥**(Callback Hell)이 펼쳐진다  
&emsp;즉, 코드의 가독성과 유지보수성이 떨어지는 문제가 발생한다
{:.notice--info}


## Promise

추가중...






<!-- 

Ajax가 널리 쓰이게 되면서 비동기 처리방법이 매우 중요해지게됩니다.
Ajax는 기본적으로 비동기적으로 서버와의 통신을 처리하기 때문에 Ajax와 기존의 동기식 코드를 함께 작성하면 코드의 실행순서에 문제가 발생합니다.
자바스크립트 엔진은 비동기 코드가 끝날때까지 다른 코드의 실행을 멈추지 않기 때문입니다.

왜 비동기 통신일까?

동기적으로 하면 사용성이 굉장히 떨어진다왜?

처리가 다 끝날때까지 동기적으로 이루어지기떄문에

```js
// sudo코드
const result = 비동기통신함수();
통신함수의결과를가공하는함수1(result);

const result2 = 비동기통신함수2();
통신함수의결과를가공하는함수2(result2);
const total = result + result2;
// 이런 방식은 불가능합니다. result와 result2에 무슨 값이 들어있을지 생각해보세요.
```

가 아닌 

```js
const total = 비동기통신함수( 
        input,
        통신함수의결과를가공하는함수1 ( 
            result, 
            비동기통신함수2(
                통신함수의결과를가공하는함수2(
                    result, 
                    result2
                )
            ) 
        ) 
    );
// 비동기적으로 받아온 데이터를 동기적으로 수행할 수 밖에 없었다
// 이렇게 비동기 함수가 끝나기 전에 중간 중간에 필요한 콜백함수를 실행시키며 사용할 수 밖에 없었습니다.
```

---

javascript object notation


자바스크립트 데이터 문법을 모방한 데이터 형태

자바스크립트는 왜 그 모양일까?

---

웹어셈블리는 웹 플랫폼에 있어서 상당히 큰 의의를 갖습니다 
여러 언어로 작성된 코드들을 네이티브에 가까운 속도로 웹에서 돌릴 수 있는 길을 제공

웹어셈블리는 브라우저에서 실행되는 JavaScript보다 빠르고 안전합니다. 이는 웹어셈블리 코드가 브라우저에서 직접 실행되기 때문입니다. 또한, 웹어셈블리는 다양한 언어로 작성된 코드를 브라우저에서 실행할 수 있기 때문에, 웹 개발자들이 다양한 언어를 사용하여 웹 애플리케이션을 개발할 수 있습니다.

---

---


https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify


---


stringify

---

Error 객체는 런타임 오류가 발생했을 때 던져집니다. Error 객체를 사용자 지정 예외의 기반 객체로 사용할 수도 있습니다. 아래 표준 내장 오류 유형을 참고하세요.

---

꼭 잡고갔으면 하는것

중요한건 초반에 몰려있었다
자료형에 따른 수많은 메서드에 충분히 익숙해진다음
클래스나 프로토타입을 들어가자

다시복습해보고 먼저 만들고 리팩토링하고 

---

console.log 계속 찍어도 비동기가 나중에 실행되는 이유 알려주세요ㅎㅎ

브라우저나 자바스크립트는 싱글스레드 환경에서 실행이되는데
사용자의 코드를 브라우저가 실행을 시킬 때 반드시 순서대로 실행되게 되어있는데 함수가 실행되는 장소를 메인 스레드라고 부르는데
메인 스레드 위에 오래걸리는 함수가 막고있으면 블로킹이됨
그래서 side스레드를 만듦 특정조건이 발생했을 때 생성되는데

그 조건이 비동기함수가 실행될때
메인스레드에서 실행시키지 않고 사이드스레드에서 따로 실행시킴
따라서 메인스레드는 계속 흘러감

비동기함수가 사이드스레드에 있다가 메인스레드가 비어지면
메인스레드로 돌아와서 작동이 되어야하는데
메인스레드에 와봤더니 다른함수가 실행되고 있다면?
충돌이 발생하는데 이런 충돌이 발생하지 않도록 하기위해
이벤트루프가 존재함 이것은 스케줄 매니저와 같음
실행하는 큐를 가지고 있음

메인스레드에 있는애가 끝나고 실행되도록 이벤트루프가 조절해줌

---

fetch API

가져오다라는 의미로 해석하면 됨

XHR과 fetch의 가장 큰 차이점은 

XMLHttpRequest 가 생성하는 인스턴스는 통신의 기능을 수행하는 XMLHttpRequest 객체를 반환했지만
fetch는 인스턴스를 만들지 않고, 대신 ‘약속’(promise)을 반환한다는 것입니다.

---

promise

resolve 메소드가 실행되면 then 메소드가 자동으로 호출됩니다.
resolve 메소드 호출이 없는 상태에서 reject 메소드가 실행되거나 통신에 문제가 발생하면 catch 메소드가 자동으로 호출됩니다.

resolve -> then
reject -> catch

---

promise는 프로미스가 반환되고
언제실행이되냐면 resolve가 실행되면 실행되는데
그럼 then메서드로 안에 있는 함수가 호출되어 리턴해서
return으로 프로미스객체를 반환되고 또 then으로 이어나가는 식

이것이 promise 체이닝

---

fetch 는 XMLHttpRequest 을 하지않고 

---

async promise가 아닌 값을 반환하는 함수로 바꾸기 때문에
then을 사용 x

---


비동기 통신 방식
자바스크립트의 비동기 통신 방식은 여러 가지가 있다. (JQuery라이브러리를 사용하는 ajax 방식은 포함하지 않았다.)

XMLHttpRequest(Web API)
Promise(callback hell을 피하기 위해 자바스크립트에서 제공하는 객체)
Fetch API (Promise 기반의 Web API)
async/await(ES2017에서 추가된 자바스크립트 키워드)

fetch API는 반환값으로 Promise 객체를 반환한다.
async/await 키워드도 반환값으로 Promise객체를 반환한다. -->